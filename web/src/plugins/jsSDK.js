// Code generated by go generate; DO NOT EDIT.
// 2024-10-09 08:30:40.276746 -0500 CDT m=+0.002923710
class JsSDK {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.election = new ElectionSDK(baseURL);
  }

  async AsyncCommandStatus({AsyncCommandID, IncludeLogs}) {
    let params = ""
    if (IncludeLogs) {
      params = "?" + new URLSearchParams({"include_logs": "true"}).toString()
    }
    const response = await fetch(`${this.baseURL}/async-command-status/${AsyncCommandID}${params}`, {
      method: "GET",
    });

    if (!response.ok) {
      throw new Error(`unable to get async command status for ${AsyncCommandID}`);
    }

    return await response.json();
  }
}

class ElectionSDK {
  constructor(baseURL) {
    this.baseURL = baseURL + "/election";
  }

  async CastVote({
                   VoteID,
                   ElectionID,
                   UserID,
                   RankedProposalIDs,
                 }) {
    return _executeCommand(this.baseURL, "CastVote", {
      VoteID,
      ElectionID,
      UserID,
      RankedProposalIDs,
    });
  }

  async CloseElectionByOwner({
                               ID,
                               ElectionID,
                             }) {
    return _executeAsyncCommand(this.baseURL, "CloseElectionByOwner", {
      ID,
      ElectionID,
    });
  }

  async CommenceElection({
                           ElectionID,
                           OrganizerUserID,
                           Name,
                           Description,
                         }) {
    return _executeCommand(this.baseURL, "CommenceElection", {
      ElectionID,
      OrganizerUserID,
      Name,
      Description,
    });
  }

  async GetElection({
                      ElectionID,
                    }) {
    return _executeQuery(this.baseURL, "GetElection", {
      ElectionID,
    });
  }

  async GetElectionResults({
                             ElectionID,
                           }) {
    return _executeQuery(this.baseURL, "GetElectionResults", {
      ElectionID,
    });
  }

  async GetProposalDetails({
                             ProposalID,
                           }) {
    return _executeQuery(this.baseURL, "GetProposalDetails", {
      ProposalID,
    });
  }

  async ListOpenElections({
                            Page,
                            ItemsPerPage,
                            SortBy,
                            SortDirection,
                          }) {
    return _executeQuery(this.baseURL, "ListOpenElections", {
      Page,
      ItemsPerPage,
      SortBy,
      SortDirection,
    });
  }

  async ListProposals({
                        ElectionID,
                        Page,
                        ItemsPerPage,
                      }) {
    return _executeQuery(this.baseURL, "ListProposals", {
      ElectionID,
      Page,
      ItemsPerPage,
    });
  }

  async MakeProposal({
                       ElectionID,
                       ProposalID,
                       OwnerUserID,
                       Name,
                       Description,
                     }) {
    return _executeCommand(this.baseURL, "MakeProposal", {
      ElectionID,
      ProposalID,
      OwnerUserID,
      Name,
      Description,
    });
  }
}

async function _executeAsyncCommand(baseURL, commandName, payload) {
  const response = await fetch(`${baseURL}/${commandName}`, {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify(payload)
  });

  if (!response.ok) {
    throw new Error(`unable to execute async command ${commandName}`);
  }

  const responseBody = await response.json();
  if (responseBody.data.attributes.Status !== "QUEUED" && responseBody.data.attributes.Status !== "OK") {
    throw new Error(`async command response was not successful for ${commandName}`);
  }
  return responseBody;
}

async function _executeCommand(baseURL, commandName, payload) {
  const response = await fetch(`${baseURL}/${commandName}`, {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify(payload)
  });

  if (!response.ok) {
    throw new Error(`unable to execute command ${commandName}`);
  }

  const responseBody = await response.json();
  if (responseBody.data.attributes.Status !== "OK") {
    throw new Error(`command response was not successful for ${commandName}`);
  }
  return responseBody;
}

async function _executeQuery(baseURL, queryName, queryParams) {
  const params = new URLSearchParams(queryParams).toString()
  const response = await fetch(`${baseURL}/${queryName}?${params}`, {
    method: "GET",
  });

  if (!response.ok) {
    throw new Error(`unable to execute query ${queryName}`);
  }

  const responseBody = await response.json();
  if (responseBody.meta.status !== "OK") {
    throw new Error(`query response was not successful for ${queryName}`);
  }
  return responseBody;
}

export {JsSDK};
